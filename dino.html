<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Juego del Dinosaurio de Google</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
  />
  <style>
    /* Reset and base styles */
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: #f7f7f7;
      overflow-x: hidden;
      font-family: 'Arial', sans-serif;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      transition: background-color 1s ease;
      position: relative;
    }

    body.night {
      background-color: #1a1a2e;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background-color: transparent;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      padding-bottom: 60px;
    }

    canvas {
      display: block;
      max-width: 900px;
      width: 100%;
      height: 300px; /* Vertical size */
      image-rendering: pixelated;
      background-color: transparent;
    }

    /* Text styles */
    #gameOverText {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-weight: 700;
      font-size: 3.5rem;
      color: #535353;
      user-select: none;
      display: none;
      text-align: center;
      transition: color 1s ease;
      z-index: 20;
    }

    body.night #gameOverText {
      color: #ddd;
    }

    #restartHint {
      position: absolute;
      top: 55%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.25rem;
      color: #888;
      user-select: none;
      display: none;
      text-align: center;
      transition: color 1s ease;
      z-index: 20;
    }

    body.night #restartHint {
      color: #bbb;
    }

    #score {
      position: absolute;
      top: 15px;
      right: 30px;
      font-weight: 700;
      font-size: 1.75rem;
      color: #535353;
      user-select: none;
      font-family: 'Courier New', Courier, monospace;
      letter-spacing: 3px;
      transition: color 1s ease;
      z-index: 20;
    }

    body.night #score {
      color: #ddd;
    }

    /* Mobile instructions */
    #instructions {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.1rem;
      color: #999;
      user-select: none;
      font-weight: 500;
      font-family: 'Arial', sans-serif;
      transition: color 1s ease;
      z-index: 20;
      max-width: 90vw;
      text-align: center;
    }

    body.night #instructions {
      color: #bbb;
    }

    /* Controls container */
    #mobileControls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 30;
      max-width: 90vw;
      width: 400px;
      justify-content: center;
    }

    /* Buttons */
    .control-button {
      background-color: #535353;
      color: white;
      font-size: 1.5rem;
      padding: 14px 20px;
      border-radius: 12px;
      user-select: none;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      transition: background-color 0.3s ease;
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      touch-action: manipulation;
    }

    .control-button:active {
      background-color: #777;
    }

    body.night .control-button {
      background-color: #ddd;
      color: #1a1a2e;
    }

    body.night .control-button:active {
      background-color: #bbb;
    }

    /* Hide controls on large screens */
    @media (min-width: 768px) {
      #mobileControls {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer" role="main" aria-label="Juego del dinosaurio de Google sin internet">
    <canvas id="gameCanvas" width="900" height="300" aria-label="Área de juego del dinosaurio"></canvas>
    <div id="score" aria-live="polite" aria-atomic="true" aria-relevant="text">00000</div>
    <div id="gameOverText" role="alert" aria-live="assertive">GAME OVER</div>
    <div id="restartHint">Presiona ESPACIO o Toca para reiniciar</div>
    <div id="instructions">Presiona ESPACIO o toca la pantalla para saltar, o flecha abajo para agacharte</div>
  </div>

  <div id="mobileControls" aria-label="Controles del juego para dispositivos móviles">
    <button id="btnJump" class="control-button" aria-label="Botón para saltar">
      <i class="fas fa-arrow-up"></i> Saltar
    </button>
    <button id="btnDuck" class="control-button" aria-label="Botón para agacharse">
      <i class="fas fa-arrow-down"></i> Agacharse
    </button>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const body = document.body;

      // Constants
      const CANVAS_WIDTH = canvas.width;
      const CANVAS_HEIGHT = canvas.height;

      // Dinosaur constants (scaled up 1.5x)
      const SCALE = 1.5;
      const DINO_WIDTH = 44 * SCALE; // 66
      const DINO_HEIGHT = 47 * SCALE; // 70.5
      const DINO_DUCK_HEIGHT = 45 * SCALE; // updated duck height to be taller so legs show
      const DINO_X = 50 * SCALE; // 75
      const GROUND_Y = CANVAS_HEIGHT - 60; // increased padding from bottom for taller canvas

      // Physics
      const GRAVITY = 0.6 * SCALE;
      const JUMP_VELOCITY = -12 * SCALE;

      // Obstacle constants
      const OBSTACLE_SPEED_START = 5 * SCALE; // start a bit slower for smoother acceleration
      const OBSTACLE_SPEED_INCREMENT = 0.0008 * SCALE; // slower acceleration
      const OBSTACLE_MIN_GAP = 350; // minimum gap between obstacles
      const OBSTACLE_MAX_GAP = 900; // maximum gap between obstacles (slightly reduced max for more frequent obstacles)

      // Cloud constants
      const CLOUD_SPEED = 1.5 * SCALE;
      const CLOUD_MIN_GAP = 270;
      const CLOUD_MAX_GAP = 675;

      // Game states
      const STATE_PLAYING = 'playing';
      const STATE_GAMEOVER = 'gameover';

      // Variables
      let dino = {
        x: DINO_X,
        y: GROUND_Y - DINO_HEIGHT,
        width: DINO_WIDTH,
        height: DINO_HEIGHT,
        vy: 0,
        isJumping: false,
        isDucking: false,
        frame: 0,
        frameCount: 0,
        blinkTimer: 0,
        blinkInterval: 3000,
        blinkDuration: 200,
        isBlinking: false,
        jumpFrame: 0,
        jumpFrameCount: 0,
        jumpAnimationFrames: 6,
        duckFrame: 0,
        duckFrameCount: 0,
        duckAnimationFrames: 4,
      };

      let obstacles = [];
      let clouds = [];

      let groundX = 0;

      let score = 0;
      let highScore = 0;

      let obstacleSpeed = OBSTACLE_SPEED_START;

      let gameState = STATE_PLAYING;

      let lastTime = 0;

      // To ensure pterodactyls appear regularly even if ground obstacles are frequent
      let framesSinceLastPtero = 0;
      const MIN_FRAMES_BETWEEN_PTERO = 60; // about 1 second at 60fps

      // To control meteor spawn timing
      let lastMeteorScore = 0;
      const METEOR_SCORE_INTERVAL = 100; // meteor every 100 points after 800

      // To control flying obstacle sequencing and interleaving with ground obstacles
      let lastObstacleWasFlying = false;
      let flyingObstacleCount = 0;
      const MAX_FLYING_OBSTACLES_IN_ROW = 3;

      // DOM elements
      const scoreEl = document.getElementById('score');
      const gameOverText = document.getElementById('gameOverText');
      const restartHint = document.getElementById('restartHint');

      // Mobile control buttons
      const btnJump = document.getElementById('btnJump');
      const btnDuck = document.getElementById('btnDuck');

      // Utility functions
      function randomBetween(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      // Dinosaur drawing (pixel art style, scaled)
      function drawDino(ctx, dino) {
        ctx.save();
        ctx.translate(dino.x, dino.y);
        ctx.scale(SCALE, SCALE);

        ctx.fillStyle = '#535353';

        if (dino.isJumping) {
          const jf = dino.jumpFrame % dino.jumpAnimationFrames;

          ctx.fillRect(0, 10, 44, 30);
          ctx.fillRect(30, 0, 14, 20);

          ctx.fillStyle = '#fff';
          ctx.fillRect(38, 6, 6, 6);
          ctx.fillStyle = '#000';
          if (dino.isBlinking) {
            ctx.fillRect(38, 9, 6, 2);
          } else {
            ctx.fillRect(40, 8, 2, 2);
          }

          ctx.fillStyle = '#535353';

          if (jf === 0 || jf === 3) {
            ctx.fillRect(12, 40, 10, 7);
            ctx.fillRect(32, 40, 10, 7);
          } else if (jf === 1 || jf === 4) {
            ctx.fillRect(8, 38, 10, 7);
            ctx.fillRect(36, 42, 10, 7);
          } else if (jf === 2 || jf === 5) {
            ctx.fillRect(5, 35, 10, 7);
            ctx.fillRect(40, 45, 10, 7);
          }

          ctx.fillRect(-10, 20, 10, 10);

        } else if (dino.isDucking) {
          dino.duckFrameCount++;
          if (dino.duckFrameCount > 6) {
            dino.duckFrame++;
            dino.duckFrameCount = 0;
            if (dino.duckFrame >= dino.duckAnimationFrames) {
              dino.duckFrame = 0;
            }
          }

          const bobOffset = [0, 2, 0, 1][dino.duckFrame];

          ctx.translate(0, bobOffset);

          ctx.fillRect(0, 25, 44, 30);
          ctx.fillRect(30, 15, 14, 20);

          ctx.fillStyle = '#fff';
          ctx.fillRect(38, 21, 6, 6);
          ctx.fillStyle = '#000';
          if (dino.isBlinking) {
            ctx.fillRect(38, 24, 6, 2);
          } else {
            ctx.fillRect(40, 23, 2, 2);
          }

          ctx.fillStyle = '#535353';
          ctx.fillRect(-10, 35, 10, 10);

          if (dino.duckFrame % 2 === 0) {
            ctx.fillRect(10, 55, 10, 7);
            ctx.fillRect(30, 55, 10, 7);
          } else {
            ctx.fillRect(5, 53, 10, 7);
            ctx.fillRect(35, 57, 10, 7);
          }

        } else {
          if (dino.frame % 4 < 2) {
            ctx.fillRect(0, 10, 44, 30);
            ctx.fillRect(30, 0, 14, 20);

            ctx.fillStyle = '#fff';
            ctx.fillRect(38, 6, 6, 6);
            ctx.fillStyle = '#000';
            if (dino.isBlinking) {
              ctx.fillRect(38, 9, 6, 2);
            } else {
              ctx.fillRect(40, 8, 2, 2);
            }

            ctx.fillStyle = '#535353';
            ctx.fillRect(10, 40, 10, 7);
            ctx.fillRect(30, 40, 10, 7);
            ctx.fillRect(-10, 20, 10, 10);
          } else {
            ctx.fillRect(0, 10, 44, 30);
            ctx.fillRect(30, 0, 14, 20);

            ctx.fillStyle = '#fff';
            ctx.fillRect(38, 6, 6, 6);
            ctx.fillStyle = '#000';
            if (dino.isBlinking) {
              ctx.fillRect(38, 9, 6, 2);
            } else {
              ctx.fillRect(40, 8, 2, 2);
            }

            ctx.fillStyle = '#535353';
            ctx.fillRect(5, 40, 10, 7);
            ctx.fillRect(35, 40, 10, 7);
            ctx.fillRect(-10, 20, 10, 10);
          }
        }

        ctx.restore();
      }

      // Obstacle drawing (scaled)
      // Pterodactyl with wing flap animation, flying low for ducking challenge
      // Meteor drawing: diagonal falling from top-right to bottom-left
      function drawObstacle(ctx, obstacle) {
        ctx.save();
        ctx.translate(obstacle.x, obstacle.y);
        ctx.scale(SCALE, SCALE);

        ctx.fillStyle = body.classList.contains('night') ? '#ddd' : '#535353';

        if (obstacle.type === 'smallCactus') {
          ctx.fillRect(0, 0, 15, 30);
          ctx.fillRect(-5, 10, 5, 10);
          ctx.fillRect(15, 5, 5, 15);
          ctx.fillRect(3, -5, 4, 5);
          ctx.fillRect(8, -8, 4, 5);
        } else if (obstacle.type === 'largeCactus') {
          ctx.fillRect(0, 0, 25, 50);
          ctx.fillRect(-7, 15, 7, 15);
          ctx.fillRect(5, -10, 5, 15);
          ctx.fillRect(25, 10, 7, 20);
          ctx.fillRect(18, -5, 5, 15);
          ctx.fillRect(8, -15, 6, 10);
          ctx.fillRect(15, -20, 6, 10);
        } else if (obstacle.type === 'pterodactyl') {
          const wingFlap = obstacle.frame % 20 < 10 ? 1 : -1;

          ctx.fillRect(0, 10, 40, 10);

          ctx.beginPath();
          ctx.moveTo(0, 10);
          ctx.lineTo(-10, 10 - 10 * wingFlap);
          ctx.lineTo(0, 20);
          ctx.closePath();
          ctx.fill();

          ctx.beginPath();
          ctx.moveTo(40, 10);
          ctx.lineTo(50, 10 - 10 * wingFlap);
          ctx.lineTo(40, 20);
          ctx.closePath();
          ctx.fill();

          ctx.fillRect(40, 5, 10, 10);
        } else if (obstacle.type === 'rock') {
          ctx.beginPath();
          ctx.moveTo(0, 30);
          ctx.lineTo(10, 10);
          ctx.quadraticCurveTo(20, 0, 40, 20);
          ctx.lineTo(50, 40);
          ctx.lineTo(0, 40);
          ctx.closePath();
          ctx.fill();

          ctx.strokeStyle = body.classList.contains('night') ? '#999' : '#3a3a3a';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(10, 30);
          ctx.lineTo(20, 20);
          ctx.moveTo(30, 35);
          ctx.lineTo(40, 25);
          ctx.stroke();
        } else if (obstacle.type === 'meteor') {
          ctx.fillStyle = '#ff6a00';
          ctx.beginPath();
          ctx.arc(10, 10, 10, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = '#ffb347';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, 20);
          ctx.lineTo(20, 0);
          ctx.stroke();
        }

        ctx.restore();
      }

      // Cloud drawing (scaled)
      function drawCloud(ctx, cloud) {
        ctx.save();
        ctx.translate(cloud.x, cloud.y);
        ctx.scale(SCALE, SCALE);
        ctx.fillStyle = body.classList.contains('night') ? '#666' : '#cfcfcf';

        ctx.beginPath();
        ctx.arc(0, 10, 10, 0, Math.PI * 2);
        ctx.arc(15, 5, 12, 0, Math.PI * 2);
        ctx.arc(30, 10, 10, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      // Draw ground line (scaled)
      function drawGround(ctx, x) {
        ctx.strokeStyle = body.classList.contains('night') ? '#ddd' : '#535353';
        ctx.lineWidth = 3 * SCALE;
        ctx.beginPath();
        ctx.moveTo(x, GROUND_Y + 1);
        ctx.lineTo(x + CANVAS_WIDTH * 2, GROUND_Y + 1);
        ctx.stroke();
      }

      // Collision detection (AABB)
      function isColliding(rect1, rect2) {
        return !(
          rect1.x + rect1.width < rect2.x ||
          rect1.x > rect2.x + rect2.width ||
          rect1.y + rect1.height < rect2.y ||
          rect1.y > rect2.y + rect2.height
        );
      }

      // Check if there is any ground obstacle (non-pterodactyl, non-meteor) currently on screen or close to spawn
      function isGroundObstacleNear() {
        for (const obs of obstacles) {
          if (obs.type !== 'pterodactyl' && obs.type !== 'meteor') {
            if (obs.x + obs.width > 0 && obs.x < CANVAS_WIDTH + 300 * SCALE) {
              return true;
            }
          }
        }
        return false;
      }

      // Create new obstacle with variable spacing and pterodactyl or meteor flying/falling
      function createObstacle() {
        framesSinceLastPtero++;
        // Meteor spawn controlled by score below

        let type;
        const groundObstacleNear = isGroundObstacleNear();

        // Flying obstacles appear after 250 points, meteors after 800 points
        const canSpawnFlying = score >= 250;
        const canSpawnMeteor = score >= 800;

        // Interleave flying and ground obstacles
        if (canSpawnFlying && !lastObstacleWasFlying && flyingObstacleCount < MAX_FLYING_OBSTACLES_IN_ROW) {
          // Spawn flying obstacle
          type = 'pterodactyl';
          lastObstacleWasFlying = true;
          flyingObstacleCount++;
          framesSinceLastPtero = 0;
        } else {
          // Spawn ground obstacle or meteor if conditions met
          lastObstacleWasFlying = false;
          flyingObstacleCount = 0;

          if (canSpawnMeteor && score - lastMeteorScore >= METEOR_SCORE_INTERVAL) {
            type = 'meteor';
            lastMeteorScore = score;
          } else {
            // Ground obstacles: smallCactus, largeCactus, rock
            const rand = Math.random();
            if (rand < 0.45) {
              type = 'smallCactus';
            } else if (rand < 0.8) {
              type = 'largeCactus';
            } else {
              type = 'rock';
            }
          }
        }

        let height;
        let y;
        let width;

        if (type === 'smallCactus') {
          height = 30 * SCALE;
          y = GROUND_Y - height;
          width = 15 * SCALE;
        } else if (type === 'largeCactus') {
          height = 50 * SCALE;
          y = GROUND_Y - height;
          width = 25 * SCALE;
        } else if (type === 'pterodactyl') {
          height = 20 * SCALE;
          const flyHeights = [GROUND_Y - 55 * SCALE, GROUND_Y - 65 * SCALE, GROUND_Y - 75 * SCALE];
          y = flyHeights[Math.floor(Math.random() * flyHeights.length)];
          width = 50 * SCALE;
        } else if (type === 'rock') {
          height = 40 * SCALE;
          y = GROUND_Y - height + 5 * SCALE;
          width = 50 * SCALE;
        } else if (type === 'meteor') {
          height = 20 * SCALE;
          width = 20 * SCALE;
          y = -height; // start above canvas
        }

        let newX;
        if (type === 'pterodactyl') {
          newX = CANVAS_WIDTH + randomBetween(100 * SCALE, 300 * SCALE);
        } else if (type === 'meteor') {
          newX = CANVAS_WIDTH + 50 * SCALE; // start near top-right corner
        } else {
          if (obstacles.length > 0) {
            const lastObs = obstacles[obstacles.length - 1];
            const gap = randomBetween(OBSTACLE_MIN_GAP, OBSTACLE_MAX_GAP);
            newX = lastObs.x + lastObs.width + gap;
          } else {
            newX = CANVAS_WIDTH + 45 * SCALE;
          }
        }

        const obstacle = {
          x: newX,
          y: y,
          width: width,
          height: height,
          type: type,
          frame: 0,
          frameCount: 0,
          direction: 1,
          speed: obstacleSpeed,
          vx: 0,
          vy: 0,
        };

        if (type === 'meteor') {
          const targetX = dino.x + dino.width / 2;
          const targetY = dino.y + dino.height;
          const startX = newX;
          const startY = y;

          const dx = targetX - startX;
          const dy = targetY - startY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const meteorSpeed = obstacleSpeed * 1.5;

          obstacle.vx = (dx / dist) * meteorSpeed;
          obstacle.vy = (dy / dist) * meteorSpeed;
        }

        obstacles.push(obstacle);
      }

      // Create new cloud
      function createCloud() {
        const cloud = {
          x: CANVAS_WIDTH + 45 * SCALE,
          y: randomBetween(20 * SCALE, 80 * SCALE),
          width: 40 * SCALE,
          height: 20 * SCALE,
          speed: CLOUD_SPEED,
        };
        clouds.push(cloud);
      }

      // Reset game
      function resetGame() {
        dino.y = GROUND_Y - DINO_HEIGHT;
        dino.vy = 0;
        dino.isJumping = false;
        dino.isDucking = false;
        dino.frame = 0;
        dino.frameCount = 0;
        dino.blinkTimer = 0;
        dino.isBlinking = false;
        dino.jumpFrame = 0;
        dino.jumpFrameCount = 0;
        dino.duckFrame = 0;
        dino.duckFrameCount = 0;

        obstacles = [];
        clouds = [];

        groundX = 0;

        score = 0;
        obstacleSpeed = OBSTACLE_SPEED_START;

        gameState = STATE_PLAYING;

        framesSinceLastPtero = MIN_FRAMES_BETWEEN_PTERO;
        lastMeteorScore = 0;
        lastObstacleWasFlying = false;
        flyingObstacleCount = 0;

        isNight = false;
        body.classList.remove('night');

        gameOverText.style.display = 'none';
        restartHint.style.display = 'none';
      }

      // Day/Night cycle management based on score
      let isNight = false;

      function updateDayNightCycleByScore() {
        const cycleIndex = Math.floor(score / 400);
        const shouldBeNight = cycleIndex % 2 === 1;
        if (shouldBeNight !== isNight) {
          isNight = shouldBeNight;
          if (isNight) {
            body.classList.add('night');
          } else {
            body.classList.remove('night');
          }
        }
      }

      // Update function
      function update(deltaTime) {
        if (gameState !== STATE_PLAYING) return;

        updateDayNightCycleByScore();

        // Update dino blink timer
        dino.blinkTimer += deltaTime;
        if (!dino.isBlinking && dino.blinkTimer > dino.blinkInterval) {
          dino.isBlinking = true;
          dino.blinkTimer = 0;
        }
        if (dino.isBlinking && dino.blinkTimer > dino.blinkDuration) {
          dino.isBlinking = false;
          dino.blinkTimer = 0;
        }

        // Update dino position and jump animation frame
        if (dino.isJumping) {
          dino.vy += GRAVITY;
          dino.y += dino.vy;

          dino.jumpFrameCount++;
          if (dino.jumpFrameCount > 4) {
            dino.jumpFrame++;
            dino.jumpFrameCount = 0;
            if (dino.jumpFrame >= dino.jumpAnimationFrames) {
              dino.jumpFrame = 0;
            }
          }

          if (dino.y >= GROUND_Y - DINO_HEIGHT) {
            dino.y = GROUND_Y - DINO_HEIGHT;
            dino.vy = 0;
            dino.isJumping = false;
            dino.jumpFrame = 0;
            dino.jumpFrameCount = 0;
          }
        } else {
          dino.frameCount++;
          if (dino.frameCount > 2) {
            dino.frame++;
            dino.frameCount = 0;
          }
        }

        // Adjust dino height if ducking
        if (dino.isDucking && !dino.isJumping) {
          dino.height = DINO_DUCK_HEIGHT;
          dino.y = GROUND_Y - dino.height;
        } else if (!dino.isJumping) {
          dino.height = DINO_HEIGHT;
          dino.y = GROUND_Y - dino.height;
        }

        // Move ground
        groundX -= obstacleSpeed;
        if (groundX <= -CANVAS_WIDTH) {
          groundX = 0;
        }

        // Move obstacles
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obs = obstacles[i];
          if (obs.type === 'pterodactyl') {
            obs.x -= obstacleSpeed * 1.2;
            if (obs.x + obs.width < 0) {
              obstacles.splice(i, 1);
              continue;
            }
            obs.frameCount++;
            if (obs.frameCount > 10) {
              obs.frame++;
              obs.frameCount = 0;
              obs.direction = obs.direction === 1 ? -1 : 1;
            }
          } else if (obs.type === 'meteor') {
            obs.x += obs.vx;
            obs.y += obs.vy;
            if (obs.x + obs.width < 0 || obs.y > CANVAS_HEIGHT) {
              obstacles.splice(i, 1);
              continue;
            }
          } else {
            obs.x -= obstacleSpeed;
            if (obs.x + obs.width < 0) {
              obstacles.splice(i, 1);
              continue;
            }
          }
        }

        // Move clouds
        for (let i = clouds.length - 1; i >= 0; i--) {
          const cloud = clouds[i];
          cloud.x -= cloud.speed;
          if (cloud.x + cloud.width < 0) {
            clouds.splice(i, 1);
          }
        }

        // Add new obstacles if needed
        if (
          obstacles.length === 0 ||
          (obstacles[obstacles.length - 1].x < CANVAS_WIDTH)
        ) {
          createObstacle();
        }

        // Add new clouds
        if (
          clouds.length === 0 ||
          (clouds.length > 0 && clouds[clouds.length - 1].x < CANVAS_WIDTH - randomBetween(CLOUD_MIN_GAP, CLOUD_MAX_GAP))
        ) {
          createCloud();
        }

        // Increase speed gradually but slowly
        obstacleSpeed += OBSTACLE_SPEED_INCREMENT;
        if (obstacleSpeed > 15 * SCALE) obstacleSpeed = 15 * SCALE;

        // Update score
        score += 0.1;
        if (score > highScore) {
          highScore = score;
        }
        scoreEl.textContent = Math.floor(score).toString().padStart(5, '0');

        // Collision detection
        const dinoRect = {
          x: dino.x,
          y: dino.y,
          width: dino.width,
          height: dino.height,
        };

        for (const obs of obstacles) {
          const obsRect = {
            x: obs.x,
            y: obs.y,
            width: obs.width,
            height: obs.height,
          };

          if (obs.type === 'pterodactyl' || obs.type === 'meteor') {
            if (dino.isDucking) {
              const duckRect = {
                x: dino.x,
                y: dino.y,
                width: dino.width,
                height: DINO_DUCK_HEIGHT,
              };
              if (isColliding(duckRect, obsRect)) {
                gameOver();
                break;
              }
            } else if (obs.type === 'meteor' && dino.isJumping) {
              if (isColliding(dinoRect, obsRect)) {
                gameOver();
                break;
              }
            } else if (obs.type === 'pterodactyl' && !dino.isDucking) {
              if (isColliding(dinoRect, obsRect)) {
                gameOver();
                break;
              }
            } else if (obs.type === 'meteor' && !dino.isDucking && !dino.isJumping) {
              if (isColliding(dinoRect, obsRect)) {
                gameOver();
                break;
              }
            }
          } else {
            if (isColliding(dinoRect, obsRect)) {
              gameOver();
              break;
            }
          }
        }
      }

      // Draw function
      function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw clouds
        for (const cloud of clouds) {
          drawCloud(ctx, cloud);
        }

        // Draw ground (two lines for infinite effect)
        drawGround(ctx, groundX);
        drawGround(ctx, groundX + CANVAS_WIDTH);

        // Draw obstacles
        for (const obs of obstacles) {
          drawObstacle(ctx, obs);
        }

        // Draw dinosaur
        drawDino(ctx, dino);
      }

      // Game over function
      function gameOver() {
        gameState = STATE_GAMEOVER;
        gameOverText.style.display = 'block';
        restartHint.style.display = 'block';
      }

      // Game loop
      function gameLoop(timestamp = 0) {
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        update(deltaTime);
        draw();

        requestAnimationFrame(gameLoop);
      }

      // Input handlers
      function jump() {
        if (gameState === STATE_PLAYING && !dino.isJumping) {
          dino.vy = JUMP_VELOCITY;
          dino.isJumping = true;
          dino.jumpFrame = 0;
          dino.jumpFrameCount = 0;
          dino.isDucking = false;
        } else if (gameState === STATE_GAMEOVER) {
          resetGame();
        }
      }

      function duckStart() {
        if (gameState === STATE_PLAYING && !dino.isJumping) {
          dino.isDucking = true;
        }
      }

      function duckEnd() {
        dino.isDucking = false;
      }

      // Keyboard
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
          e.preventDefault();
          jump();
        } else if (e.code === 'ArrowDown') {
          e.preventDefault();
          duckStart();
        }
      });

      window.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowDown') {
          e.preventDefault();
          duckEnd();
        }
      });

      // Touch (tap to jump, swipe down to duck)
      let touchStartY = null;
      window.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          touchStartY = e.touches[0].clientY;
        }
      }, { passive: true });

      window.addEventListener('touchmove', (e) => {
        if (!touchStartY) return;
        const touchCurrentY = e.touches[0].clientY;
        const diffY = touchCurrentY - touchStartY;
        if (diffY > 30) {
          duckStart();
        } else if (diffY < -30) {
          jump();
        }
      }, { passive: true });

      window.addEventListener('touchend', (e) => {
        duckEnd();
        touchStartY = null;
      });

      // Mobile buttons events
      btnJump.addEventListener('touchstart', (e) => {
        e.preventDefault();
        jump();
      }, { passive: false });

      btnJump.addEventListener('mousedown', (e) => {
        e.preventDefault();
        jump();
      });

      btnDuck.addEventListener('touchstart', (e) => {
        e.preventDefault();
        duckStart();
      }, { passive: false });

      btnDuck.addEventListener('touchend', (e) => {
        e.preventDefault();
        duckEnd();
      }, { passive: false });

      btnDuck.addEventListener('mousedown', (e) => {
        e.preventDefault();
        duckStart();
      });

      btnDuck.addEventListener('mouseup', (e) => {
        e.preventDefault();
        duckEnd();
      });

      btnDuck.addEventListener('mouseleave', (e) => {
        e.preventDefault();
        duckEnd();
      });

      // Initialize
      resetGame();
      requestAnimationFrame(gameLoop);
    })();
  </script>
</body>
</html>
