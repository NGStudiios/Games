<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Juego del Dinosaurio de Google</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
  />
  <style>
    /* Reset and base styles */
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: #f7f7f7;
      overflow-x: hidden;
      font-family: 'Arial', sans-serif;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background-color: #f7f7f7;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      padding-bottom: 60px;
    }

    canvas {
      display: block;
      background-color: #f7f7f7;
      max-width: 900px;
      width: 100%;
      height: 300px; /* Vertical size */
      image-rendering: pixelated;
    }

    /* Text styles */
    #gameOverText {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-weight: 700;
      font-size: 3.5rem;
      color: #535353;
      user-select: none;
      display: none;
      text-align: center;
    }

    #restartHint {
      position: absolute;
      top: 55%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.25rem;
      color: #888;
      user-select: none;
      display: none;
      text-align: center;
    }

    #score {
      position: absolute;
      top: 15px;
      right: 30px;
      font-weight: 700;
      font-size: 1.75rem;
      color: #535353;
      user-select: none;
      font-family: 'Courier New', Courier, monospace;
      letter-spacing: 3px;
    }

    /* Mobile instructions */
    #instructions {
      position: absolute;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.1rem;
      color: #999;
      user-select: none;
      font-weight: 500;
      font-family: 'Arial', sans-serif;
    }
  </style>
</head>
<body>
  <div id="gameContainer" role="main" aria-label="Juego del dinosaurio de Google sin internet">
    <canvas id="gameCanvas" width="900" height="300" aria-label="Ãrea de juego del dinosaurio"></canvas>
    <div id="score" aria-live="polite" aria-atomic="true" aria-relevant="text">00000</div>
    <div id="gameOverText" role="alert" aria-live="assertive">GAME OVER</div>
    <div id="restartHint">Presiona ESPACIO o Toca para reiniciar</div>
    <div id="instructions">Presiona ESPACIO o toca la pantalla para saltar, o flecha abajo para agacharte</div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      // Constants
      const CANVAS_WIDTH = canvas.width;
      const CANVAS_HEIGHT = canvas.height;

      // Dinosaur constants (scaled up 1.5x)
      const SCALE = 1.5;
      const DINO_WIDTH = 44 * SCALE; // 66
      const DINO_HEIGHT = 47 * SCALE; // 70.5
      const DINO_DUCK_HEIGHT = 35 * SCALE; // improved duck height
      const DINO_X = 50 * SCALE; // 75
      const GROUND_Y = CANVAS_HEIGHT - 60; // increased padding from bottom for taller canvas

      // Physics
      const GRAVITY = 0.6 * SCALE;
      const JUMP_VELOCITY = -12 * SCALE;

      // Obstacle constants
      const OBSTACLE_SPEED_START = 6 * SCALE;
      const OBSTACLE_SPEED_INCREMENT = 0.0025 * SCALE;
      const OBSTACLE_MIN_GAP = 350; // minimum gap between obstacles
      const OBSTACLE_MAX_GAP = 950; // maximum gap between obstacles (increased max for more variability)

      // Cloud constants
      const CLOUD_SPEED = 1.5 * SCALE;
      const CLOUD_MIN_GAP = 270;
      const CLOUD_MAX_GAP = 675;

      // Game states
      const STATE_PLAYING = 'playing';
      const STATE_GAMEOVER = 'gameover';

      // Variables
      let dino = {
        x: DINO_X,
        y: GROUND_Y - DINO_HEIGHT,
        width: DINO_WIDTH,
        height: DINO_HEIGHT,
        vy: 0,
        isJumping: false,
        isDucking: false,
        frame: 0,
        frameCount: 0,
        blinkTimer: 0,
        blinkInterval: 3000,
        blinkDuration: 200,
        isBlinking: false,
        jumpFrame: 0,
        jumpFrameCount: 0,
        jumpAnimationFrames: 6,
        duckFrame: 0,
        duckFrameCount: 0,
        duckAnimationFrames: 4,
      };

      let obstacles = [];
      let clouds = [];

      let groundX = 0;

      let score = 0;
      let highScore = 0;

      let obstacleSpeed = OBSTACLE_SPEED_START;

      let gameState = STATE_PLAYING;

      let lastTime = 0;

      // DOM elements
      const scoreEl = document.getElementById('score');
      const gameOverText = document.getElementById('gameOverText');
      const restartHint = document.getElementById('restartHint');

      // Utility functions
      function randomBetween(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      // Dinosaur drawing (pixel art style, scaled)
      // Improved duck animation with smooth frame cycling and body position adjustment
      function drawDino(ctx, dino) {
        ctx.save();
        ctx.translate(dino.x, dino.y);
        ctx.scale(SCALE, SCALE);

        ctx.fillStyle = '#535353';

        if (dino.isJumping) {
          const jf = dino.jumpFrame % dino.jumpAnimationFrames;

          ctx.fillRect(0, 10, 44, 30);
          ctx.fillRect(30, 0, 14, 20);

          ctx.fillStyle = '#fff';
          ctx.fillRect(38, 6, 6, 6);
          ctx.fillStyle = '#000';
          if (dino.isBlinking) {
            ctx.fillRect(38, 9, 6, 2);
          } else {
            ctx.fillRect(40, 8, 2, 2);
          }

          ctx.fillStyle = '#535353';

          if (jf === 0 || jf === 3) {
            ctx.fillRect(12, 40, 10, 7);
            ctx.fillRect(32, 40, 10, 7);
          } else if (jf === 1 || jf === 4) {
            ctx.fillRect(8, 38, 10, 7);
            ctx.fillRect(36, 42, 10, 7);
          } else if (jf === 2 || jf === 5) {
            ctx.fillRect(5, 35, 10, 7);
            ctx.fillRect(40, 45, 10, 7);
          }

          ctx.fillRect(-10, 20, 10, 10);

        } else if (dino.isDucking) {
          // Ducking animation: cycle frames for smooth bobbing
          dino.duckFrameCount++;
          if (dino.duckFrameCount > 6) {
            dino.duckFrame++;
            dino.duckFrameCount = 0;
            if (dino.duckFrame >= dino.duckAnimationFrames) {
              dino.duckFrame = 0;
            }
          }

          // Vertical offset for bobbing effect
          const bobOffset = [0, 2, 0, 1][dino.duckFrame];

          ctx.translate(0, bobOffset);

          // Body lower and wider
          ctx.fillRect(0, 35, 44, 20);
          ctx.fillRect(30, 25, 14, 15);

          ctx.fillStyle = '#fff';
          ctx.fillRect(38, 31, 6, 6);
          ctx.fillStyle = '#000';
          if (dino.isBlinking) {
            ctx.fillRect(38, 34, 6, 2);
          } else {
            ctx.fillRect(40, 33, 2, 2);
          }

          ctx.fillStyle = '#535353';
          // Tail tucked lower and slightly shifted for duck
          ctx.fillRect(-10, 45, 10, 10);

        } else {
          if (dino.frame % 4 < 2) {
            ctx.fillRect(0, 10, 44, 30);
            ctx.fillRect(30, 0, 14, 20);

            ctx.fillStyle = '#fff';
            ctx.fillRect(38, 6, 6, 6);
            ctx.fillStyle = '#000';
            if (dino.isBlinking) {
              ctx.fillRect(38, 9, 6, 2);
            } else {
              ctx.fillRect(40, 8, 2, 2);
            }

            ctx.fillStyle = '#535353';
            ctx.fillRect(10, 40, 10, 7);
            ctx.fillRect(30, 40, 10, 7);
            ctx.fillRect(-10, 20, 10, 10);
          } else {
            ctx.fillRect(0, 10, 44, 30);
            ctx.fillRect(30, 0, 14, 20);

            ctx.fillStyle = '#fff';
            ctx.fillRect(38, 6, 6, 6);
            ctx.fillStyle = '#000';
            if (dino.isBlinking) {
              ctx.fillRect(38, 9, 6, 2);
            } else {
              ctx.fillRect(40, 8, 2, 2);
            }

            ctx.fillStyle = '#535353';
            ctx.fillRect(5, 40, 10, 7);
            ctx.fillRect(35, 40, 10, 7);
            ctx.fillRect(-10, 20, 10, 10);
          }
        }

        ctx.restore();
      }

      // Obstacle drawing (scaled)
      function drawObstacle(ctx, obstacle) {
        ctx.save();
        ctx.translate(obstacle.x, obstacle.y);
        ctx.scale(SCALE, SCALE);

        ctx.fillStyle = '#535353';

        if (obstacle.type === 'smallCactus') {
          ctx.fillRect(0, 0, 15, 30);
          ctx.fillRect(5, -10, 5, 10);
          ctx.fillRect(10, -5, 5, 5);
        } else if (obstacle.type === 'largeCactus') {
          ctx.fillRect(0, 0, 25, 50);
          ctx.fillRect(5, -15, 5, 15);
          ctx.fillRect(15, -10, 5, 10);
          ctx.fillRect(20, -5, 5, 5);
        } else if (obstacle.type === 'pterodactyl') {
          // Flying right to left (normal)
          ctx.fillRect(0, 10, 40, 10);
          ctx.beginPath();
          ctx.moveTo(0, 10);
          ctx.lineTo(-10, 0);
          ctx.lineTo(0, 20);
          ctx.closePath();
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(40, 10);
          ctx.lineTo(50, 0);
          ctx.lineTo(40, 20);
          ctx.closePath();
          ctx.fill();
          ctx.fillRect(40, 5, 10, 10);
        } else if (obstacle.type === 'rock') {
          ctx.beginPath();
          ctx.moveTo(0, 30);
          ctx.lineTo(10, 10);
          ctx.quadraticCurveTo(20, 0, 40, 20);
          ctx.lineTo(50, 40);
          ctx.lineTo(0, 40);
          ctx.closePath();
          ctx.fill();

          ctx.strokeStyle = '#3a3a3a';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(10, 30);
          ctx.lineTo(20, 20);
          ctx.moveTo(30, 35);
          ctx.lineTo(40, 25);
          ctx.stroke();
        } else if (obstacle.type === 'bird') {
          // Bird flying right to left, resembling pterodactyl with wing flap animation
          const wingFlap = obstacle.frame % 20 < 10 ? 1 : -1;

          // Body
          ctx.fillRect(0, 10, 40, 10);

          // Wings flapping up/down
          ctx.beginPath();
          ctx.moveTo(0, 10);
          ctx.lineTo(-10, 10 - 10 * wingFlap);
          ctx.lineTo(0, 20);
          ctx.closePath();
          ctx.fill();

          ctx.beginPath();
          ctx.moveTo(40, 10);
          ctx.lineTo(50, 10 - 10 * wingFlap);
          ctx.lineTo(40, 20);
          ctx.closePath();
          ctx.fill();

          // Head
          ctx.fillRect(40, 5, 10, 10);
        }

        ctx.restore();
      }

      // Cloud drawing (scaled)
      function drawCloud(ctx, cloud) {
        ctx.save();
        ctx.translate(cloud.x, cloud.y);
        ctx.scale(SCALE, SCALE);
        ctx.fillStyle = '#cfcfcf';

        ctx.beginPath();
        ctx.arc(0, 10, 10, 0, Math.PI * 2);
        ctx.arc(15, 5, 12, 0, Math.PI * 2);
        ctx.arc(30, 10, 10, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      // Draw ground line (scaled)
      function drawGround(ctx, x) {
        ctx.strokeStyle = '#535353';
        ctx.lineWidth = 3 * SCALE;
        ctx.beginPath();
        ctx.moveTo(x, GROUND_Y + 1);
        ctx.lineTo(x + CANVAS_WIDTH * 2, GROUND_Y + 1);
        ctx.stroke();
      }

      // Collision detection (AABB)
      function isColliding(rect1, rect2) {
        return !(
          rect1.x + rect1.width < rect2.x ||
          rect1.x > rect2.x + rect2.width ||
          rect1.y + rect1.height < rect2.y ||
          rect1.y > rect2.y + rect2.height
        );
      }

      // Create new obstacle with variable spacing and bird flying right to left
      function createObstacle() {
        const types = ['smallCactus', 'largeCactus', 'pterodactyl', 'rock', 'bird'];
        let type;

        if (score > 500) {
          const rand = Math.random();
          if (rand < 0.2) {
            type = 'pterodactyl';
          } else if (rand < 0.35) {
            type = 'bird';
          } else if (rand < 0.55) {
            type = 'rock';
          } else if (rand < 0.8) {
            type = 'smallCactus';
          } else {
            type = 'largeCactus';
          }
        } else {
          const rand = Math.random();
          if (rand < 0.35) {
            type = 'smallCactus';
          } else if (rand < 0.6) {
            type = 'largeCactus';
          } else if (rand < 0.8) {
            type = 'rock';
          } else {
            type = 'bird';
          }
        }

        let height;
        let y;
        let width;

        if (type === 'smallCactus') {
          height = 30 * SCALE;
          y = GROUND_Y - height;
          width = 15 * SCALE;
        } else if (type === 'largeCactus') {
          height = 50 * SCALE;
          y = GROUND_Y - height;
          width = 25 * SCALE;
        } else if (type === 'pterodactyl') {
          height = 20 * SCALE;
          const flyHeights = [GROUND_Y - 100 * SCALE, GROUND_Y - 75 * SCALE, GROUND_Y - 50 * SCALE];
          y = flyHeights[Math.floor(Math.random() * flyHeights.length)];
          width = 50 * SCALE;
        } else if (type === 'rock') {
          height = 40 * SCALE;
          y = GROUND_Y - height + 5 * SCALE;
          width = 50 * SCALE;
        } else if (type === 'bird') {
          height = 20 * SCALE;
          // Bird flies at a fixed height above dino, flying right to left from right side
          y = GROUND_Y - 90 * SCALE;
          width = 50 * SCALE;
        }

        let newX;
        if (type === 'bird') {
          // Bird flies right to left, start off right side beyond canvas
          newX = CANVAS_WIDTH + randomBetween(100 * SCALE, 300 * SCALE);
        } else {
          // Normal obstacles spawn off right side with variable gap
          if (obstacles.length > 0) {
            const lastObs = obstacles[obstacles.length - 1];
            const gap = randomBetween(OBSTACLE_MIN_GAP, OBSTACLE_MAX_GAP);
            newX = lastObs.x + lastObs.width + gap;
          } else {
            newX = CANVAS_WIDTH + 45 * SCALE;
          }
        }

        const obstacle = {
          x: newX,
          y: y,
          width: width,
          height: height,
          type: type,
          frame: 0,
          frameCount: 0,
          direction: 1,
          speed: obstacleSpeed,
        };

        obstacles.push(obstacle);
      }

      // Create new cloud
      function createCloud() {
        const cloud = {
          x: CANVAS_WIDTH + 45 * SCALE,
          y: randomBetween(20 * SCALE, 80 * SCALE),
          width: 40 * SCALE,
          height: 20 * SCALE,
          speed: CLOUD_SPEED,
        };
        clouds.push(cloud);
      }

      // Reset game
      function resetGame() {
        dino.y = GROUND_Y - DINO_HEIGHT;
        dino.vy = 0;
        dino.isJumping = false;
        dino.isDucking = false;
        dino.frame = 0;
        dino.frameCount = 0;
        dino.blinkTimer = 0;
        dino.isBlinking = false;
        dino.jumpFrame = 0;
        dino.jumpFrameCount = 0;
        dino.duckFrame = 0;
        dino.duckFrameCount = 0;

        obstacles = [];
        clouds = [];

        groundX = 0;

        score = 0;
        obstacleSpeed = OBSTACLE_SPEED_START;

        gameState = STATE_PLAYING;

        gameOverText.style.display = 'none';
        restartHint.style.display = 'none';
      }

      // Update function
      function update(deltaTime) {
        if (gameState !== STATE_PLAYING) return;

        // Update dino blink timer
        dino.blinkTimer += deltaTime;
        if (!dino.isBlinking && dino.blinkTimer > dino.blinkInterval) {
          dino.isBlinking = true;
          dino.blinkTimer = 0;
        }
        if (dino.isBlinking && dino.blinkTimer > dino.blinkDuration) {
          dino.isBlinking = false;
          dino.blinkTimer = 0;
        }

        // Update dino position and jump animation frame
        if (dino.isJumping) {
          dino.vy += GRAVITY;
          dino.y += dino.vy;

          dino.jumpFrameCount++;
          if (dino.jumpFrameCount > 4) {
            dino.jumpFrame++;
            dino.jumpFrameCount = 0;
            if (dino.jumpFrame >= dino.jumpAnimationFrames) {
              dino.jumpFrame = 0;
            }
          }

          if (dino.y >= GROUND_Y - DINO_HEIGHT) {
            dino.y = GROUND_Y - DINO_HEIGHT;
            dino.vy = 0;
            dino.isJumping = false;
            dino.jumpFrame = 0;
            dino.jumpFrameCount = 0;
          }
        } else {
          // Animate dino legs much faster when running
          dino.frameCount++;
          if (dino.frameCount > 2) {
            dino.frame++;
            dino.frameCount = 0;
          }
        }

        // Adjust dino height if ducking
        if (dino.isDucking && !dino.isJumping) {
          dino.height = DINO_DUCK_HEIGHT;
          dino.y = GROUND_Y - dino.height;
        } else if (!dino.isJumping) {
          dino.height = DINO_HEIGHT;
          dino.y = GROUND_Y - dino.height;
        }

        // Move ground
        groundX -= obstacleSpeed;
        if (groundX <= -CANVAS_WIDTH) {
          groundX = 0;
        }

        // Move obstacles
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obs = obstacles[i];
          if (obs.type === 'bird') {
            // Bird flies right to left
            obs.x -= obstacleSpeed * 1.2; // slightly faster than obstacles
            if (obs.x + obs.width < 0) {
              obstacles.splice(i, 1);
            }
          } else {
            obs.x -= obstacleSpeed;
            if (obs.x + obs.width < 0) {
              obstacles.splice(i, 1);
            }
          }

          // Animate pterodactyl and bird wings flapping
          if (obs.type === 'pterodactyl' || obs.type === 'bird') {
            obs.frameCount++;
            if (obs.frameCount > 10) {
              obs.frame++;
              obs.frameCount = 0;
              obs.direction = obs.direction === 1 ? -1 : 1;
            }
          }
        }

        // Move clouds
        for (let i = clouds.length - 1; i >= 0; i--) {
          const cloud = clouds[i];
          cloud.x -= cloud.speed;
          if (cloud.x + cloud.width < 0) {
            clouds.splice(i, 1);
          }
        }

        // Add new obstacles if needed
        if (
          obstacles.length === 0 ||
          (obstacles[obstacles.length - 1].x < CANVAS_WIDTH)
        ) {
          createObstacle();
        }

        // Add new clouds
        if (
          clouds.length === 0 ||
          (clouds[clouds.length - 1].x < CANVAS_WIDTH - randomBetween(CLOUD_MIN_GAP, CLOUD_MAX_GAP))
        ) {
          createCloud();
        }

        // Increase speed gradually
        obstacleSpeed += OBSTACLE_SPEED_INCREMENT;

        // Update score
        score += 0.1;
        if (score > highScore) {
          highScore = score;
        }
        scoreEl.textContent = Math.floor(score).toString().padStart(5, '0');

        // Collision detection
        const dinoRect = {
          x: dino.x,
          y: dino.y,
          width: dino.width,
          height: dino.height,
        };

        for (const obs of obstacles) {
          const obsRect = {
            x: obs.x,
            y: obs.y,
            width: obs.width,
            height: obs.height,
          };

          // Special collision for bird: player must duck to avoid
          if (obs.type === 'bird') {
            if (dino.isDucking) {
              const duckRect = {
                x: dino.x,
                y: dino.y,
                width: dino.width,
                height: DINO_DUCK_HEIGHT,
              };
              if (isColliding(duckRect, obsRect)) {
                gameOver();
                break;
              }
            } else {
              if (isColliding(dinoRect, obsRect)) {
                gameOver();
                break;
              }
            }
          } else {
            if (isColliding(dinoRect, obsRect)) {
              gameOver();
              break;
            }
          }
        }
      }

      // Draw function
      function draw() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw clouds
        for (const cloud of clouds) {
          drawCloud(ctx, cloud);
        }

        // Draw ground (two lines for infinite effect)
        drawGround(ctx, groundX);
        drawGround(ctx, groundX + CANVAS_WIDTH);

        // Draw obstacles
        for (const obs of obstacles) {
          drawObstacle(ctx, obs);
        }

        // Draw dinosaur
        drawDino(ctx, dino);
      }

      // Game over function
      function gameOver() {
        gameState = STATE_GAMEOVER;
        gameOverText.style.display = 'block';
        restartHint.style.display = 'block';
      }

      // Game loop
      function gameLoop(timestamp = 0) {
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        update(deltaTime);
        draw();

        requestAnimationFrame(gameLoop);
      }

      // Input handlers
      function jump() {
        if (gameState === STATE_PLAYING && !dino.isJumping) {
          dino.vy = JUMP_VELOCITY;
          dino.isJumping = true;
          dino.jumpFrame = 0;
          dino.jumpFrameCount = 0;
          dino.isDucking = false;
        } else if (gameState === STATE_GAMEOVER) {
          resetGame();
        }
      }

      function duckStart() {
        if (gameState === STATE_PLAYING && !dino.isJumping) {
          dino.isDucking = true;
        }
      }

      function duckEnd() {
        dino.isDucking = false;
      }

      // Keyboard
      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
          e.preventDefault();
          jump();
        } else if (e.code === 'ArrowDown') {
          e.preventDefault();
          duckStart();
        }
      });

      window.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowDown') {
          e.preventDefault();
          duckEnd();
        }
      });

      // Touch (tap to jump, swipe down to duck)
      let touchStartY = null;
      window.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          touchStartY = e.touches[0].clientY;
        }
      }, { passive: true });

      window.addEventListener('touchmove', (e) => {
        if (!touchStartY) return;
        const touchCurrentY = e.touches[0].clientY;
        const diffY = touchCurrentY - touchStartY;
        if (diffY > 30) {
          duckStart();
        } else if (diffY < -30) {
          jump();
        }
      }, { passive: true });

      window.addEventListener('touchend', (e) => {
        duckEnd();
        touchStartY = null;
      });

      // Initialize
      resetGame();
      requestAnimationFrame(gameLoop);
    })();
  </script>
</body>
</html>
