<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flappy Bird con Tailwind - Mejorado</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
  />
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      background: linear-gradient(to bottom, #70c5ce, #5dade2);
      overflow: hidden;
      font-family: 'Arial', sans-serif;
    }
    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: #70c5ce;
      border: 3px solid #333;
      border-radius: 12px;
      max-width: 100vw;
      height: 600px;
      width: 400px;
      touch-action: manipulation;
      position: relative;
      z-index: 0;
    }
    @media (max-width: 440px) {
      #gameCanvas {
        width: 100vw;
        height: calc(100vw * 1.5);
      }
    }
    /* Estilos para la pantalla de game over */
    #gameOverScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      border-radius: 16px;
      padding: 2rem 3rem;
      color: #f87171; /* rojo claro */
      font-weight: 900;
      font-size: 2rem;
      text-align: center;
      width: 90%;
      max-width: 320px;
      box-shadow: 0 0 20px #f87171;
      user-select: none;
      display: none;
      z-index: 10;
    }
    #gameOverScreen button {
      margin-top: 1.5rem;
      background-color: #f87171;
      color: white;
      font-weight: 700;
      padding: 0.75rem 1.5rem;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s ease;
      font-size: 1.1rem;
      box-shadow: 0 4px 8px rgb(248 113 113 / 0.6);
    }
    #gameOverScreen button:hover {
      background-color: #ef4444;
      box-shadow: 0 6px 12px rgb(239 68 68 / 0.8);
    }
  </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 bg-gradient-to-b from-sky-400 to-blue-600 relative">

  <h1 class="text-white text-4xl font-extrabold mb-6 select-none">Flappy Bird - Juego</h1>

  <div class="relative">
    <canvas id="gameCanvas" width="400" height="600" aria-label="Juego Flappy Bird"></canvas>

    <div id="gameOverScreen" role="alert" aria-live="assertive" aria-atomic="true" aria-hidden="true">
      <div>¡Juego terminado!</div>
      <div class="mt-2 text-lg font-semibold text-red-300">Tu puntuación final es: <span id="finalScore">0</span></div>
      <button id="restartBtn" aria-label="Reiniciar juego">Jugar de nuevo</button>
    </div>
  </div>

  <div class="mt-6 flex flex-col items-center space-y-4">
    <button
      id="startBtn"
      class="px-6 py-3 bg-yellow-400 hover:bg-yellow-500 text-gray-900 font-bold rounded-lg shadow-lg transition"
      aria-label="Iniciar juego"
    >
      Iniciar Juego
    </button>
    <div class="text-white text-lg font-semibold select-none" aria-live="polite" aria-atomic="true">
      Puntuación: <span id="score">0</span>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const startBtn = document.getElementById('startBtn');
      const scoreEl = document.getElementById('score');
      const gameOverScreen = document.getElementById('gameOverScreen');
      const finalScoreEl = document.getElementById('finalScore');
      const restartBtn = document.getElementById('restartBtn');

      // Ajuste para retina
      function setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = 400 * dpr;
        canvas.height = 600 * dpr;
        canvas.style.width = '400px';
        canvas.style.height = '600px';
        ctx.scale(dpr, dpr);
      }
      setupCanvas();

      // Variables del juego
      const bird = {
        x: 80,
        y: 300,
        width: 34,
        height: 24,
        gravity: 0.6,
        lift: -10,
        velocity: 0,
        maxVelocity: 12,
        radius: 12,
      };

      const pipeWidth = 60;
      const pipeGap = 150;
      const pipeSpeed = 2;
      const pipes = [];

      let frameCount = 0;
      let score = 0;
      let gameRunning = false;

      // Función para reiniciar el juego
      function resetGame() {
        bird.y = 300;
        bird.velocity = 0;
        pipes.length = 0;
        scoreEl.textContent = score;
        frameCount = 0;
        gameOverScreen.style.display = 'none';
        gameOverScreen.setAttribute('aria-hidden', 'true');
      }

      // Crear un nuevo par de tuberías
      function createPipe() {
        const minPipeHeight = 50;
        const maxPipeHeight = 300;
        const pipeNorthHeight = Math.floor(Math.random() * (maxPipeHeight - minPipeHeight + 1)) + minPipeHeight;
        const pipeSouthY = pipeNorthHeight + pipeGap;

        pipes.push({
          x: canvas.width / (window.devicePixelRatio || 1),
          yNorth: pipeNorthHeight - 400,
          ySouth: pipeSouthY,
          width: pipeWidth,
          passed: false,
          radius: 20,
        });
      }

      // Detectar colisiones con tubos redondeados
      function checkCollision(pipe) {
        // Bird circle
        const bx = bird.x + bird.radius;
        const by = bird.y + bird.radius;
        const br = bird.radius;

        // Pipe rectangles with rounded edges
        const px = pipe.x;
        const pw = pipe.width;
        const radius = pipe.radius;

        // Tubería norte (parte visible)
        const pyNorth = pipe.yNorth + 400;

        // Tubería sur (parte visible)
        const pySouth = pipe.ySouth;

        // Colisión con tubería norte (top pipe)
        if (bx + br > px && bx - br < px + pw) {
          if (by - br < pyNorth) {
            const cx1 = px + radius;
            const cy1 = pyNorth;
            const cx2 = px + pw - radius;
            const cy2 = pyNorth;

            if (by - br < pyNorth - radius) {
              return true;
            }

            const dist1 = Math.hypot(bx - cx1, by - cy1);
            const dist2 = Math.hypot(bx - cx2, by - cy2);
            if (dist1 < br + radius || dist2 < br + radius) {
              return true;
            }
          }
        }

        // Colisión con tubería sur (bottom pipe)
        if (bx + br > px && bx - br < px + pw) {
          if (by + br > pySouth) {
            const cx1 = px + radius;
            const cy1 = pySouth;
            const cx2 = px + pw - radius;
            const cy2 = pySouth;

            if (by + br > pySouth + radius) {
              return true;
            }

            const dist1 = Math.hypot(bx - cx1, by - cy1);
            const dist2 = Math.hypot(bx - cx2, by - cy2);
            if (dist1 < br + radius || dist2 < br + radius) {
              return true;
            }
          }
        }

        return false;
      }

      // Dibujar el pájaro con forma circular y detalles
      function drawBird() {
        const x = bird.x + bird.radius;
        const y = bird.y + bird.radius;
        const r = bird.radius;

        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.ellipse(x, y, r + 4, r + 3, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#FFEC8B';
        ctx.beginPath();
        ctx.ellipse(x, y, r, r - 1, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#E6C200';
        ctx.beginPath();
        ctx.ellipse(x + 3, y + 2, r / 2, r / 3, Math.PI / 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(x + 6, y - 2, r / 4, r / 4, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#FF8C00';
        ctx.beginPath();
        ctx.moveTo(x + r + 2, y);
        ctx.lineTo(x + r + 10, y - 4);
        ctx.lineTo(x + r + 10, y + 4);
        ctx.closePath();
        ctx.fill();
      }

      // Dibujar tubos con bordes redondeados y detalles
      function drawPipes() {
        pipes.forEach((pipe) => {
          const x = pipe.x;
          const w = pipe.width;
          const radius = pipe.radius;

          const topHeight = pipe.yNorth + 400;
          drawPipeSegment(x, 0, w, topHeight, radius, true);

          const bottomY = pipe.ySouth;
          const bottomHeight = canvas.height / (window.devicePixelRatio || 1) - 80 - bottomY;
          drawPipeSegment(x, bottomY, w, bottomHeight, radius, false);
        });
      }

      // Función para dibujar un tubo con bordes redondeados y detalles
      function drawPipeSegment(x, y, width, height, radius, isTop) {
        ctx.fillStyle = '#2E8B57';
        ctx.strokeStyle = '#1E5631';
        ctx.lineWidth = 4;

        ctx.beginPath();
        if (isTop) {
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + height - radius);
          ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
          ctx.lineTo(x + width - radius, y + height);
          ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
          ctx.lineTo(x + width, y);
          ctx.closePath();
        } else {
          ctx.moveTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          ctx.lineTo(x + width, y + height);
          ctx.lineTo(x, y + height);
          ctx.closePath();
        }
        ctx.fill();
        ctx.stroke();

        ctx.strokeStyle = '#3CB371';
        ctx.lineWidth = 1.5;
        const linesCount = 6;
        const spacing = width / (linesCount + 1);
        for (let i = 1; i <= linesCount; i++) {
          const lineX = x + i * spacing;
          ctx.beginPath();
          ctx.moveTo(lineX, y + 10);
          ctx.lineTo(lineX, y + height - 10);
          ctx.stroke();
        }

        const grad = ctx.createLinearGradient(x, y, x + width, y);
        grad.addColorStop(0, 'rgba(0,0,0,0.15)');
        grad.addColorStop(0.5, 'rgba(255,255,255,0.15)');
        grad.addColorStop(1, 'rgba(0,0,0,0.15)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        if (isTop) {
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + height - radius);
          ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
          ctx.lineTo(x + width - radius, y + height);
          ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
          ctx.lineTo(x + width, y);
          ctx.closePath();
        } else {
          ctx.moveTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          ctx.lineTo(x + width, y + height);
          ctx.lineTo(x, y + height);
          ctx.closePath();
        }
        ctx.fill();
      }

      // Dibujar el suelo con textura simple
      function drawGround() {
        const groundY = canvas.height / (window.devicePixelRatio || 1) - 80;
        const groundHeight = 80;

        ctx.fillStyle = '#DEB887';
        ctx.fillRect(0, groundY, canvas.width / (window.devicePixelRatio || 1), groundHeight);

        ctx.strokeStyle = '#C19A6B';
        ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
          const y = groundY + i * 10 + 5;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width / (window.devicePixelRatio || 1), y);
          ctx.stroke();
        }
      }

      // Dibujar el cielo (gradiente)
      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height / (window.devicePixelRatio || 1));
        gradient.addColorStop(0, '#70c5ce');
        gradient.addColorStop(1, '#5dade2');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width / (window.devicePixelRatio || 1), canvas.height / (window.devicePixelRatio || 1));
      }

      // Actualizar la lógica del juego
      function update() {
        if (!gameRunning) return;

        frameCount++;

        bird.velocity += bird.gravity;
        bird.velocity = Math.min(bird.velocity, bird.maxVelocity);
        bird.y += bird.velocity;

        // Permitir que el pájaro toque el suelo sin perder
        const groundY = canvas.height / (window.devicePixelRatio || 1) - 80;
        if (bird.y + bird.height > groundY) {
          bird.y = groundY - bird.height;
          bird.velocity = 0;
        }

        if (bird.y < 0) {
          bird.y = 0;
          bird.velocity = 0;
        }

        if (frameCount % 100 === 0) {
          createPipe();
        }

        pipes.forEach((pipe, index) => {
          pipe.x -= pipeSpeed;

          if (!pipe.passed && pipe.x + pipe.width < bird.x) {
            pipe.passed = true;
            score++;
            scoreEl.textContent = score;
          }

          if (pipe.x + pipe.width < 0) {
            pipes.splice(index, 1);
          }

          if (checkCollision(pipe)) {
            endGame();
          }
        });
      }

      // Dibujar todo
      function draw() {
        drawBackground();
        drawPipes();
        drawGround();
        drawBird();
      }

      // Loop principal
      function gameLoop() {
        if (!gameRunning) return;
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }

      // Función para iniciar el juego
      function startGame() {
        score = 0;
        resetGame();
        scoreEl.textContent = score;
        gameRunning = true;
        gameOverScreen.style.display = 'none';
        gameOverScreen.setAttribute('aria-hidden', 'true');
        startBtn.disabled = true;
        startBtn.classList.add('opacity-50', 'cursor-not-allowed');
        gameLoop();
      }

      // Función para terminar el juego
      function endGame() {
        gameRunning = false;
        finalScoreEl.textContent = score;
        gameOverScreen.style.display = 'block';
        gameOverScreen.setAttribute('aria-hidden', 'false');
        startBtn.disabled = false;
        startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
      }

      // Función para que el pájaro "vuele" al hacer click o tocar
      function flap() {
        if (!gameRunning) return;
        bird.velocity = bird.lift;
      }

      // Eventos para controlar el juego
      startBtn.addEventListener('click', () => {
        startGame();
      });

      restartBtn.addEventListener('click', () => {
        startGame();
      });

      canvas.addEventListener('mousedown', flap);
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        flap();
      }, { passive: false });

      window.addEventListener('keydown', (e) => {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
          e.preventDefault();
          if (!gameRunning) {
            startGame();
          } else {
            flap();
          }
        }
      });

      // Mensaje inicial en canvas
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Presiona "Iniciar Juego" o barra espaciadora para comenzar', canvas.width / 2 / (window.devicePixelRatio || 1), canvas.height / 2 / (window.devicePixelRatio || 1));
    })();
  </script>
</body>
</html>
